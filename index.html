<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tsm: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tsm
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">tsm Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Documentation"></a>For a primer on UML state machines, look <a href="https://en.wikipedia.org/wiki/UML_state_machine">here</a>.</p>
<h4><a class="anchor" id="autotoc_md0"></a>
Using tsm</h4>
<p>Create the state machine by inheriting from Hsm using CRTP. </p><div class="fragment"><div class="line">struct GarageDoorHsm : public Hsm&lt;GarageDoorHsm&gt;</div>
<div class="line">{</div>
<div class="line">   GarageDoorHsm()</div>
<div class="line">   {</div>
<div class="line">       setStartState(&amp;doorClosed);</div>
<div class="line"> </div>
<div class="line">       // TransitionTable</div>
<div class="line">       add(doorClosed, click_event, doorOpening);</div>
<div class="line">       add(doorOpening, topSensor_event, doorOpen);</div>
<div class="line">       ...</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   // States</div>
<div class="line">   State doorOpen, doorOpening;</div>
<div class="line">   ...</div>
<div class="line">   // Events</div>
<div class="line">   Event click_event;</div>
<div class="line">   ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Wrap the state machine around an execution policy. Currently, there are two options.</p>
<p>a. A state machine that executes in the context of the parent thread. This means that the client sending events to the state machine drives the event processing as well. Typically, this will be the 'main' thread of your application driving event processing. Note that several other threads can hold references to the state machine instance and queue up events (see 'd' below). </p><div class="fragment"><div class="line">SingleThreadedHsm&lt;GarageDoorHsm&gt; sm;</div>
</div><!-- fragment --><p>b. A state machine that processes incomming events in its own thread. i.e. Events will be immediately consumed as long as the state machine is not busy. Clients 'fire and forget' an event and desire no control over event processing. </p><div class="fragment"><div class="line">AsyncExecutionPolicy&lt;GarageDoorHsm&gt; sm;</div>
</div><!-- fragment --><p>c. Send events to the state machine by using sendEvent method provided by the policy. </p><div class="fragment"><div class="line">sm.sendEvent(sm.doorOpen);</div>
</div><!-- fragment --><p>d. If the state machine is running in parent thread context, invoke the <code>step</code> method to process the first event in the event queue. As opposed to the <code>SingleThreadedExecutionPolicy</code>, the <code>AsyncExecutionPolicy</code> will immediately process an event on completion of prior event processing.</p>
<p>For a complete example see <a href="https://github.com/tinverse/tsm/blob/main/test/GarageDoorSM.h">GarageDoorHsm.h</a> and <a href="https://github.com/tinverse/tsm/blob/main/test/GarageDoorSM.cpp">GarageDoorHsm.cpp</a>. Also look at <a href="https://github.com/tinverse/tsm/blob/main/test/CdPlayerHsm.h">CdPlayerHsm.h</a> <a href="https://github.com/tinverse/tsm/blob/main/test/CdPlayerHsm.cpp">CdPlayerHsm.cpp</a></p>
<div class="fragment"><div class="line">sm.step();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1"></a>
Architecture</h3>
<h4><a class="anchor" id="autotoc_md2"></a>
Policy based design</h4>
<p>Classes have been partitioned across policies so they can be mixed and matched for code reuse (in an ideal world)! The current architecture supports state machines with the following characterestics. </p><div class="fragment"><div class="line">a. Hierarchical -</div>
<div class="line">b. Asynchronous</div>
<div class="line">c. Parallel/Orthogonal</div>
<div class="line">d. History Preserving</div>
</div><!-- fragment --><p>Other Policy classes <em>can</em> be implemented for distributed event processing. The existing mechanism can also be extended to incorporate custom behavior such as writing state transitions to disk. For e.g. see <code>struct AsyncExecWithObserver</code> in <code><a class="el" href="AsyncExecutionPolicy_8h.html">AsyncExecutionPolicy.h</a></code></p>
<p>Clients need to include <a class="el" href="tsm_8h.html">tsm.h</a> file and link against the libtsm library.</p>
<p>The design uses CRTP to force Actions and Guards to be callbacks that are part of your Hsm class. See the implementation of</p>
<div class="fragment"><div class="line">  template &lt;typename HsmDef&gt;</div>
<div class="line">  struct Hsm : public IHsm, public State {</div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>HsmDef</code> structure tells <code>Hsm</code> about its States, Events, Actions and Guard functions. In return the <code>Hsm</code> struct creates a <code>StateTransitionTable</code>. In the <code>HsmDef</code>'s constructor, the user gets to connect child Hsms with parents by calling something like <code>Playing.setParent(this)</code> as in the <a class="el" href="CdPlayerHsm_8h.html">CdPlayerHsm.h</a><a href="https://en.wikipedia.org/wiki/UML_state_machine">1</a> example. State transitions should be specified in the constructor with the <code>add</code> method provided by the <code>Hsm</code>.</p>
<h4><a class="anchor" id="autotoc_md3"></a>
Hsm</h4>
<p>Place holder for your own application specific sate machine definition. For e.g. you might create your own Hsm called <code>CdPlayerHsm</code>. This Hsm should inherit from <code>Hsm</code> using CRTP.</p>
<div class="fragment"><div class="line">  struct CdPlayerHsm : public Hsm&lt;CdPlayerHsm&gt; {</div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md4"></a>
Hierarchical StateMachine Interface</h4>
<p>The <code>IHsm</code> interface forces all Hsms to implement functionality that is common to all Hsms. Methods <code>startSM</code> and <code>stopSM</code> are self explanatory. The <code>dispatch</code> method, when overridden makes decisions on which State gets to process an Event. This is different for <code>Hsm</code> and <code>OrthogonalHsm</code>. <code>Hsm</code> forwards the event to be processed to the innermost Hsm/State. In one of the policy classes, <code>execute</code> is then invoked on that (innermost) Hsm. See <code>AsyncExecutionPolicy::processEvent</code>. Policy classes will invoke the <code>dispatch</code> method of an Hsm and call <code>execute</code> on the state that is returned by the dispatch mechanism. Note that we are dispatching states in Hsms so that an event can be "dispatched" to the appropriate state.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
Policy Classes</h4>
<p>Policy classes like <code>AsyncExecutionPolicy</code> and <code>SingleThreadedExecutionPolicy</code> are mixins that operate on <code>StateType</code>s i.e. any type with <code>onEntry</code> and <code>onExit</code> methods that can be overridden. Clients will typically interact with a Policy class at the bottom of the inheritance hierarcy. By convention, these Policy classes also provide a <code>sendEvent</code> method as a public interface to the state machine. The <code>SingleThreadedExecutionPolicy</code> class also provides a <code>step</code> method for clients to initiate event processing.</p>
<p>The <code>AsyncExecutionPolicy</code> processes events in its own thread. The processing of events is single threaded within all Hsms. So when a Hsm is started using a call to <code>startSM</code>, the <code>StateMachine</code> will block on the call to <code>nextEvent</code> in the <code>execute</code> method. The main advantage is that the only external interface to the Hsm can be the EventQueue. Any "client" can asynchronously send an event to the state machine long as they have a reference to it. As soon as the Hsm is done with its processing, it will pick up the first event in the queue and process it. This can be seen in the test/*.cpp files.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Disadvantages</h4>
<ul>
<li><code><a class="el" href="structtsm_1_1State.html">tsm::State</a></code> - The State type implements the IState interface which has three virtual methods. Most often there are useless calls to the <code>execute</code>, <code>onEntry</code> and <code>onExit</code> methods of <code><a class="el" href="structtsm_1_1State.html">tsm::State</a></code>. Support for barebones enum State or a c-style State type with just a unique id - without any of the bells and whistles associated with <code>IState</code> should make it more compact and efficient.</li>
<li>Use of virtual methods - The implementation closely resembles the State pattern. The states are created at run-time and not compile time like boost::hsm. However, it is easier to wrap around your head. In my experience with Medical/Embedded devices, a lot of the 'in house' state machines are closer to <code>tsm</code> in terms of design and implementation.</li>
<li>Fsm or Hsm? - Not every state machine is or needs to be Hierarchical. That distinction is fuzzified here and is clubbed together for brevity. <code>tsm</code> has gone back and forth on this separation a couple of times. Future use of this library might dictate how this is handled in the implementation.</li>
</ul>
<h4><a class="anchor" id="autotoc_md7"></a>
Advantages</h4>
<ul>
<li>Integration - A lot of effort went into integration using CMake. This should make it easier for modern C++ development.</li>
<li>Unit Tests - Althought the framework could use a lot more unit tests, most of the code (98%) has been tested for 'happy path' cases.</li>
<li>Architecture - Hopefully, the ability to add your own policy classes makes it adaptable to your applications.</li>
</ul>
<h4><a class="anchor" id="autotoc_md8"></a>
Putting it all together</h4>
<p>Create your own state machine definition that derives from <code>Hsm</code>. The Hsm hierarchy, its states (and sub-Hsms if any), events, actions and guards are all specified and defined in the definition. The relationships between Hsms(<code>child.setParent(this)</code>) and the state transition table(<code>add(fromState, onEvent, toState, action, guard)</code>) are also specified here. All code related to your Hsm lives here. Then choose a policy class for your state machine. Complete your state machine type by wrapping the policy class around it. The unit test provided below is illustrative.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> StateType&gt;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="structtsm_1_1AsyncExecWithObserver.html">AsyncBlockingObserver</a> =</div>
<div class="line">  <a class="code" href="structtsm_1_1AsyncExecWithObserver.html">tsm::AsyncExecWithObserver&lt;StateType, BlockingObserver&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> <a class="code" href="structtsm_1_1AsyncExecWithObserver.html">GarageDoorHsmSeparateThread</a> = <a class="code" href="structtsm_1_1AsyncExecWithObserver.html">AsyncBlockingObserver&lt;GarageDoorHsm&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="CdPlayerHsm_8cpp.html#aad2ad36474072a985dcc117b3386c1f0">TEST_CASE</a>(<span class="stringliteral">&quot;TestGarageDoorSM - testGarageDoorSeparateThreadPolicy&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> sm = std::make_shared&lt;GarageDoorHsmSeparateThread&gt;();</div>
<div class="line"> </div>
<div class="line">    sm-&gt;startSM();</div>
<div class="line"> </div>
<div class="line">    sm-&gt;wait();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorClosed);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;sendEvent(sm-&gt;click_event);</div>
<div class="line">    sm-&gt;wait();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorOpening);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;sendEvent(sm-&gt;topSensor_event);</div>
<div class="line">    sm-&gt;wait();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorOpen);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;stopSM();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="CdPlayerHsm_8cpp.html#aad2ad36474072a985dcc117b3386c1f0">TEST_CASE</a>(<span class="stringliteral">&quot;TestGarageDoorSM - testGarageDoorSingleThreadPolicy&quot;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> sm = std::make_shared&lt;SingleThreadedHsm&lt;GarageDoorHsm&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">    sm-&gt;sendEvent(sm-&gt;click_event);</div>
<div class="line">    sm-&gt;sendEvent(sm-&gt;topSensor_event);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;startSM();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorClosed);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;step();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorOpening);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;step();</div>
<div class="line">    REQUIRE(sm-&gt;getCurrentState() == &amp;sm-&gt;doorOpen);</div>
<div class="line"> </div>
<div class="line">    sm-&gt;stopSM();</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md9"></a>
Testing</h4>
<p>For testing the <code>AsyncExecutionPolicy</code>, the <code>AsyncExecWithObserver</code> class is used with a special <code>Observer</code> class that blocks the parent thread until the <code>AsyncExecutionPolicy</code> finishes event processing. The state machine thread then calls a <code>notify</code> method that releases the mutex blocking the parent thread. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="astructtsm_1_1AsyncExecWithObserver_html"><div class="ttname"><a href="structtsm_1_1AsyncExecWithObserver.html">tsm::AsyncExecWithObserver</a></div><div class="ttdef"><b>Definition:</b> AsyncExecutionPolicy.h:90</div></div>
<div class="ttc" id="aCdPlayerHsm_8cpp_html_aad2ad36474072a985dcc117b3386c1f0"><div class="ttname"><a href="CdPlayerHsm_8cpp.html#aad2ad36474072a985dcc117b3386c1f0">TEST_CASE</a></div><div class="ttdeci">TEST_CASE(&quot;TestCdPlayerHsm - testTransitionsSeparateThreadPolicy&quot;)</div><div class="ttdef"><b>Definition:</b> CdPlayerHsm.cpp:30</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
